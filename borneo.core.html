<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>borneo.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Borneo 0.5.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>borneo</span></div></div></li><li class="depth-2 current"><a href="borneo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="borneo.core.html#var-*exec-eng*"><div class="inner"><span>*exec-eng*</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-*neo-db*"><div class="inner"><span>*neo-db*</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-add-label.21"><div class="inner"><span>add-label!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-all-nodes"><div class="inner"><span>all-nodes</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-all-nodes-with-label"><div class="inner"><span>all-nodes-with-label</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-all-rel-types"><div class="inner"><span>all-rel-types</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-create-child.21"><div class="inner"><span>create-child!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-create-labeled-node.21"><div class="inner"><span>create-labeled-node!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-create-node.21"><div class="inner"><span>create-node!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-create-rel.21"><div class="inner"><span>create-rel!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-cypher"><div class="inner"><span>cypher</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-delete.21"><div class="inner"><span>delete!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-delete-node.21"><div class="inner"><span>delete-node!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-dynamic-label"><div class="inner"><span>dynamic-label</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-end-node"><div class="inner"><span>end-node</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-find-nodes"><div class="inner"><span>find-nodes</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-get-id"><div class="inner"><span>get-id</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-get-path"><div class="inner"><span>get-path</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-index"><div class="inner"><span>index</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-label.3F"><div class="inner"><span>label?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-node-by-id"><div class="inner"><span>node-by-id</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-other-node"><div class="inner"><span>other-node</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-prop"><div class="inner"><span>prop</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-prop.3F"><div class="inner"><span>prop?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-props"><div class="inner"><span>props</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-purge.21"><div class="inner"><span>purge!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-read-only.3F"><div class="inner"><span>read-only?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-rel-by-id"><div class="inner"><span>rel-by-id</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-rel-nodes"><div class="inner"><span>rel-nodes</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-rel-type"><div class="inner"><span>rel-type</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-rel.3F"><div class="inner"><span>rel?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-rels"><div class="inner"><span>rels</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-remove-label.21"><div class="inner"><span>remove-label!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-ReturnableEvaluator"><div class="inner"><span>ReturnableEvaluator</span></div></a></li><li class="depth-2"><a href="borneo.core.html#var-returnable-node.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>returnable-node?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-set-prop.21"><div class="inner"><span>set-prop!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-set-props.21"><div class="inner"><span>set-props!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-single-rel"><div class="inner"><span>single-rel</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-start.21"><div class="inner"><span>start!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-start-node"><div class="inner"><span>start-node</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-stop.21"><div class="inner"><span>stop!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-StopEvaluator"><div class="inner"><span>StopEvaluator</span></div></a></li><li class="depth-2"><a href="borneo.core.html#var-stop-node.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stop-node?</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-traverse"><div class="inner"><span>traverse</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-walk"><div class="inner"><span>walk</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-with-db.21"><div class="inner"><span>with-db!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-with-local-db.21"><div class="inner"><span>with-local-db!</span></div></a></li><li class="depth-1"><a href="borneo.core.html#var-with-tx"><div class="inner"><span>with-tx</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">borneo.core</h2><div class="doc"><pre class="plaintext">Clojure wrapper for Neo4j, a graph database.

See project page (<a href="http://github.com/wagjo/borneo)">http://github.com/wagjo/borneo)</a> for usage instructions,
documentation and examples.

Notes:
- Using official Neo4j bindings.
- Not using Blueprints interface.
- neo-db holds the current db instance, so that users do not have
  to supply db instance at each call to db operations. This approach has
  of course some drawbacks , but I&apos;ve found it suitable for my purposes.
- All mutable functions are by default wrapped in transactions. That
  means you don&apos;t have to explicitly put them in transactions. The Neo4j
  transaction model allows for fast transaction nesting, so you can easily
  have your own transaction if you have a group of mutable functions.
  In that case just wrap your functions inside with-tx.
- NullPointerException is thrown if there is no open connection to the db.</pre></div><div class="public anchor" id="var-*exec-eng*"><h3>*exec-eng*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Holds an execution engine around the graph database to use for Cypher queries.
</pre></div></div><div class="public anchor" id="var-*neo-db*"><h3>*neo-db*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Holds the current database instance.
</pre></div></div><div class="public anchor" id="var-add-label.21"><h3>add-label!</h3><div class="usage"><code>(add-label! node name)</code></div><div class="doc"><pre class="plaintext">Adds the given label to the node.
</pre></div></div><div class="public anchor" id="var-all-nodes"><h3>all-nodes</h3><div class="usage"><code>(all-nodes)</code></div><div class="doc"><pre class="plaintext">Returns lazy-seq of all nodes in the db.
</pre></div></div><div class="public anchor" id="var-all-nodes-with-label"><h3>all-nodes-with-label</h3><div class="usage"><code>(all-nodes-with-label label-name)</code></div><div class="doc"><pre class="plaintext">Returns lazy-seq of all nodes with the given label.
</pre></div></div><div class="public anchor" id="var-all-rel-types"><h3>all-rel-types</h3><div class="usage"><code>(all-rel-types)</code></div><div class="doc"><pre class="plaintext">Returns lazy seq of all relationship types currently in database.
</pre></div></div><div class="public anchor" id="var-create-child.21"><h3>create-child!</h3><div class="usage"><code>(create-child! node type props)</code></div><div class="doc"><pre class="plaintext">Creates a node that is a child of the specified parent node
along the specified relationship.
props is a map that defines the properties of the node.
This is a convenience function.</pre></div></div><div class="public anchor" id="var-create-labeled-node.21"><h3>create-labeled-node!</h3><div class="usage"><code>(create-labeled-node! &amp; label-names)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-create-node.21"><h3>create-node!</h3><div class="usage"><code>(create-node!)</code><code>(create-node! props &amp; label-names)</code></div><div class="doc"><pre class="plaintext">Creates a new node, not linked with any other nodes.
Labels can optionally be provided to add to the node.</pre></div></div><div class="public anchor" id="var-create-rel.21"><h3>create-rel!</h3><div class="usage"><code>(create-rel! from type to)</code></div><div class="doc"><pre class="plaintext">Creates relationship of a supplied type between from and to nodes.
</pre></div></div><div class="public anchor" id="var-cypher"><h3>cypher</h3><div class="usage"><code>(cypher query)</code><code>(cypher query params)</code></div><div class="doc"><pre class="plaintext">Returns lazy-seq of results from a Cypher query
</pre></div></div><div class="public anchor" id="var-delete.21"><h3>delete!</h3><div class="usage"><code>(delete! item)</code></div><div class="doc"><pre class="plaintext">Deletes node or relationship.
Only node which has no relationships attached to it can be deleted.</pre></div></div><div class="public anchor" id="var-delete-node.21"><h3>delete-node!</h3><div class="usage"><code>(delete-node! node)</code></div><div class="doc"><pre class="plaintext">Delete node and all its relationships.
This is a convenience function.</pre></div></div><div class="public anchor" id="var-dynamic-label"><h3>dynamic-label</h3><div class="usage"><code>(dynamic-label name)</code></div><div class="doc"><pre class="plaintext">Creates a label with the supplied name
</pre></div></div><div class="public anchor" id="var-end-node"><h3>end-node</h3><div class="usage"><code>(end-node r)</code></div><div class="doc"><pre class="plaintext">Returns end node for given relationship.
</pre></div></div><div class="public anchor" id="var-find-nodes"><h3>find-nodes</h3><div class="usage"><code>(find-nodes label-name key val)</code></div><div class="doc"><pre class="plaintext">Finds nodes with the supplied label and predicate
</pre></div></div><div class="public anchor" id="var-get-id"><h3>get-id</h3><div class="usage"><code>(get-id item)</code></div><div class="doc"><pre class="plaintext">Returns id for a given node or relationship.
Note that ids are not very good as unique identifiers.</pre></div></div><div class="public anchor" id="var-get-path"><h3>get-path</h3><div class="usage"><code>(get-path)</code></div><div class="doc"><pre class="plaintext">Returns path to where the database is stored.
</pre></div></div><div class="public anchor" id="var-index"><h3>index</h3><div class="usage"><code>(index)</code></div><div class="doc"><pre class="plaintext">Returns the IndexManager paired with this graph database service.
</pre></div></div><div class="public anchor" id="var-label.3F"><h3>label?</h3><div class="usage"><code>(label? node label-name)</code></div><div class="doc"><pre class="plaintext">Returns true if the given node
has a label with the supplied name</pre></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels node)</code></div><div class="doc"><pre class="plaintext">Lists all labels attached to this node.
</pre></div></div><div class="public anchor" id="var-node-by-id"><h3>node-by-id</h3><div class="usage"><code>(node-by-id id)</code></div><div class="doc"><pre class="plaintext">Returns node with a given id, or nil if no such node exists.
Note that ids are not very good as unique identifiers.</pre></div></div><div class="public anchor" id="var-other-node"><h3>other-node</h3><div class="usage"><code>(other-node r node)</code></div><div class="doc"><pre class="plaintext">Returns other node for given relationship.
This is a convenience function.</pre></div></div><div class="public anchor" id="var-prop"><h3>prop</h3><div class="usage"><code>(prop c k)</code></div><div class="doc"><pre class="plaintext">Returns property value based on its key.
If property is not found, returns nil.
If property value is string which starts with colon,
it is converted to keyword.</pre></div></div><div class="public anchor" id="var-prop.3F"><h3>prop?</h3><div class="usage"><code>(prop? c k)</code></div><div class="doc"><pre class="plaintext">Returns true if given node or relationship contains
property with a given key.</pre></div></div><div class="public anchor" id="var-props"><h3>props</h3><div class="usage"><code>(props c)</code></div><div class="doc"><pre class="plaintext">Returns map of properties for a given node or relationship.
Fetches all properties and can be very resource consuming if node
contains many large properties. This is a convenience function.
If property value is string which starts with colon,
is is converted to keyword.</pre></div></div><div class="public anchor" id="var-purge.21"><h3>purge!</h3><div class="usage"><code>(purge!)</code></div><div class="doc"><pre class="plaintext">Deletes all nodes from database together with all relationships.
</pre></div></div><div class="public anchor" id="var-read-only.3F"><h3>read-only?</h3><div class="usage"><code>(read-only?)</code></div><div class="doc"><pre class="plaintext">Returns true if database is read only.
</pre></div></div><div class="public anchor" id="var-rel-by-id"><h3>rel-by-id</h3><div class="usage"><code>(rel-by-id id)</code></div><div class="doc"><pre class="plaintext">Returns relationship with a given id, or nil if no such relationship exists.
Note that ids are not very good as unique identifiers.</pre></div></div><div class="public anchor" id="var-rel-nodes"><h3>rel-nodes</h3><div class="usage"><code>(rel-nodes r)</code></div><div class="doc"><pre class="plaintext">Returns the two nodes attached to the given relationship.
This is a convenience function.</pre></div></div><div class="public anchor" id="var-rel-type"><h3>rel-type</h3><div class="usage"><code>(rel-type r)</code></div><div class="doc"><pre class="plaintext">Returns type of given relationship.
</pre></div></div><div class="public anchor" id="var-rel.3F"><h3>rel?</h3><div class="usage"><code>(rel? node)</code><code>(rel? node type-or-types)</code><code>(rel? node type direction)</code></div><div class="doc"><pre class="plaintext">Returns true if there are relationships attached to this node. Syntax:
[node]                - All relationships.
[node type-or-types]  - Relationships of any of specified types with
                        any direction.
[node type direction] - Relationships of specified type and
                        of specified direction. You can supply nil for
                        one of the arguments if you do not care for
                        either direction of relationship type.
Valid directions are :in :out and :both, parameter type can be any keyword.
Examples: (rel? node)                  ; All rels
          (rel? node :foo)             ; Rels of :foo type of any direction
          (rel? node [:foo :bar :baz]) ; Rels of any of specified types,
                                       ; any directions
          (rel? node :foo :in)         ; Rels of :foo type, :in direction
          (rel? node nil :in)          ; Rels of any type of :in direction
          (rel? node :foo nil)         ; Use (rel? node :foo) instead</pre></div></div><div class="public anchor" id="var-rels"><h3>rels</h3><div class="usage"><code>(rels node)</code><code>(rels node type-or-types)</code><code>(rels node type direction)</code></div><div class="doc"><pre class="plaintext">Returns relationships attached to this node. Syntax:
[node]                - All relationships.
[node type-or-types]  - Relationships of any of specified types with
                        any direction.
[node type direction] - Relationships of specified type and
                        of specified direction. You can supply nil for
                        one of the arguments if you do not care for
                        either direction of relationship type.
Valid directions are :in :out and :both, parameter type can be any keyword.
Examples: (rels node)                  ; All rels
          (rels node :foo)             ; Rels of :foo type of any direction
          (rels node [:foo :bar :baz]) ; Rels of any of specified types,
                                       ; any directions
          (rels node :foo :in)         ; Rels of :foo type, :in direction
          (rels node nil :in)          ; Rels of any type of :in direction
          (rels node :foo nil)         ; Use (rel node :foo) instead</pre></div></div><div class="public anchor" id="var-remove-label.21"><h3>remove-label!</h3><div class="usage"><code>(remove-label! node name)</code></div><div class="doc"><pre class="plaintext">Removes the supplied label from the node.
</pre></div></div><div class="public anchor" id="var-ReturnableEvaluator"><h3>ReturnableEvaluator</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for return evaluation. Used for graph traversing.
Functions:
(returnable-node? [this pos]) - Should return true if node should
                                be returned. pos will be current
                                position map.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-returnable-node.3F"><h3>returnable-node?</h3><div class="usage"><code>(returnable-node? this pos)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-set-prop.21"><h3>set-prop!</h3><div class="usage"><code>(set-prop! c key)</code><code>(set-prop! c key value)</code></div><div class="doc"><pre class="plaintext">Sets or remove property for a given node or relationship.
The property value must be one of the valid property types
(see Neo4j docs) or a keyword.
If a property value is nil, removes this property from the given
node or relationship.</pre></div></div><div class="public anchor" id="var-set-props.21"><h3>set-props!</h3><div class="usage"><code>(set-props! c props)</code></div><div class="doc"><pre class="plaintext">Sets properties for a given node or relationship.
The property value must be one of the valid property types
(see Neo4j docs) or a keyword.
If a property value is nil, removes this property from the given
node or relationship. This is a convenience function.</pre></div></div><div class="public anchor" id="var-single-rel"><h3>single-rel</h3><div class="usage"><code>(single-rel node type)</code><code>(single-rel node type direction)</code></div><div class="doc"><pre class="plaintext">Returns the only relationship for the node of the given type and
direction.
Valid directions are :in :out and :both, defaults to :out.</pre></div></div><div class="public anchor" id="var-start.21"><h3>start!</h3><div class="usage"><code>(start! path)</code></div><div class="doc"><pre class="plaintext">Establish a connection to the database.
Uses *neo-db* Var to hold the connection.
Uses *exec-eng* Var to reuse for Cypher queries.
Do not use this function, use with-db! or with-local-db! instead.</pre></div></div><div class="public anchor" id="var-start-node"><h3>start-node</h3><div class="usage"><code>(start-node r)</code></div><div class="doc"><pre class="plaintext">Returns start node for given relationship.
</pre></div></div><div class="public anchor" id="var-stop.21"><h3>stop!</h3><div class="usage"><code>(stop!)</code></div><div class="doc"><pre class="plaintext">Closes a connection stored in *neo-db*.
Do not use this function, use with-db! or with-local-db! instead.</pre></div></div><div class="public anchor" id="var-StopEvaluator"><h3>StopEvaluator</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for stop evaluation. Used for graph traversing.
Functions:
(stop-node? [this pos]) - Should return true if at stop node.
                          pos will be current position map.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-stop-node.3F"><h3>stop-node?</h3><div class="usage"><code>(stop-node? this pos)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-traverse"><h3>traverse</h3><div class="usage"><code>(traverse node rel)</code><code>(traverse node return-eval rel)</code><code>(traverse node stop-eval return-eval rel)</code><code>(traverse node order stop-eval return-eval rel)</code></div><div class="doc"><pre class="plaintext">Traverses the graph. Starting at the given node, traverse the graph
in specified order, stopping based on stop-eval. The return-eval
decides which nodes make it into the result. The rel is used to
decide which edges to traverse.
order - :breadth, :depth. Will be :depth if nil supplied.
stop-eval accepts following values:
  - :end or nil - End of graph.
  - :1, :2, :X (X being any positive integer) - Depth of X.
  - Custom function which takes one argument, current position
    and should return true when at stop node.
return-eval accepts following values:
  - :all-but-start or nil  - all but start nodes.
  - :all - all nodes.
  - Custom function which takes one argument, current position map
    and should return true when node at current position should be returned.
  - Map defining key-value pairs that will be matched against
    properties of wanna-be returned nodes.
rel - Keyword representing relation type or a map where keys are
      relation type keywords and values are directions (:in or :out).</pre></div></div><div class="public anchor" id="var-walk"><h3>walk</h3><div class="usage"><code>(walk node &amp; types)</code></div><div class="doc"><pre class="plaintext">Walks through the graph by following specified relations. Returns last node.
Throws NullPointerException if path is wrong.
Throws NotFoundException if path is ambiguous.</pre></div></div><div class="public anchor" id="var-with-db.21"><h3>with-db!</h3><h4 class="type">macro</h4><div class="usage"><code>(with-db! path &amp; body)</code></div><div class="doc"><pre class="plaintext">Establish a connection to the neo db.
Because there is an overhead when establishing connection, users should
not call this macro often. Also note that this macro is not threadsafe.</pre></div></div><div class="public anchor" id="var-with-local-db.21"><h3>with-local-db!</h3><h4 class="type">macro</h4><div class="usage"><code>(with-local-db! path &amp; body)</code></div><div class="doc"><pre class="plaintext">Establish a connection to the neo db. Connection is visible
only in current thread. Because there is an overhead when
establishing connection, users should not call this macro often.
This is a treadsafe version, which limits connection to
the current thread only. This allows you to have parallel
connections to different databases. It is not recommended to use
this function together with with-db! in one program.</pre></div></div><div class="public anchor" id="var-with-tx"><h3>with-tx</h3><h4 class="type">macro</h4><div class="usage"><code>(with-tx &amp; body)</code></div><div class="doc"><pre class="plaintext">Establish a transaction. Use it for mutable db operations.
If you do not want to commit it, throw an exception.
All mutable functions use transactions by default, so you don&apos;t
have to use this macro. You should use this macro to group your
functions into a bigger transactions.</pre></div></div></div></body></html>